# リアルタイム描画同期機能設計書

## 1. 要件定義

### 1.1. 問題の再定義

ユーザーより以下の現象が報告されました。
1. ボードxにユーザーAが描画し、保存を行う
2. ボードxにユーザーAがさらに描画する
3. ボードxにユーザーBが参加する。このとき、**2の状態が表示されてほしいところが1のみ描画される**。

この結果、ユーザーAとユーザーBの間でボードの状態が異なる状態になってしまう。

### 1.2. 解決すべき要件

上記の現象を踏まえ、以下の要件を解決します。

*   **新規参加ユーザーの描画状態の完全な再現**:
    *   ユーザーが描画ボードに参加した際、その時点でのボードの最新状態（保存された`canvas_data`と、それ以降の未保存の`drawing_elements`の両方を含む）を正確に表示できること。
*   **リアルタイムコラボレーションの維持**:
    *   ボードに参加している全ユーザー間で、描画の変更がリアルタイムに同期されること。
*   **データの整合性と効率性の両立**:
    *   `canvas_data`と`drawing_elements`の適切な管理により、データの整合性を保ちつつ、データベースの肥大化を防ぐこと。
    *   特に、保存されていない新しい`drawing_elements`が誤って削除されないようにすること。

## 2. 調査

### 2.1. 現在の描画ボード初期ロードロジック

`frontend/src/pages/DrawingBoard.tsx` の `useEffect` 内で `fetchDrawingData` 関数がボードの初期ロードを行っています。

```javascript
  useEffect(() => {
    const fetchDrawingData = async () => {
      if (!drawingId) { /* ... */ }

      try {
        // Step 1: Try to fetch canvas_data from the new endpoint
        const response = await fetch(
          `${import.meta.env.VITE_API_URL}/api/v1/drawings/${drawingId}`,
          { /* ... */ }
        );

        // ... response handling ...

        const data = await response.json();

        if (data.canvas_data) {
          // If canvas_data exists, use it
          setDrawingElements(JSON.parse(data.canvas_data));
          setLastSavedAt(data.last_saved_at ? new Date(data.last_saved_at) : null);
          setIsDirty(false);
        } else {
          // If canvas_data does not exist, fetch drawing elements as fallback
          await fetchDrawingElementsFallback(drawingId);
        }
      } catch (e: any) { /* ... */ } finally { /* ... */ }
    };

    const fetchDrawingElementsFallback = async (id: number) => {
      try {
        const response = await fetch(
          `${import.meta.env.VITE_API_URL}/api/v1/drawings/${id}/elements`,
          { /* ... */ }
        );
        // ... response handling ...
        const data = await response.json();
        setDrawingElements(data.drawing_elements || []);
        setLastSavedAt(data.last_saved_at ? new Date(data.last_saved_at) : null);
        setIsDirty(false);
      } catch (e: any) { /* ... */ }
    };

    fetchDrawingData();
  }, [drawingId]);
```

このロジックの問題点は以下の通りです。

*   `canvas_data`が存在する場合、`drawing_elements`は**一切読み込まれません**。
*   `canvas_data`は、ユーザーが明示的に「保存」ボタンを押した時点でのボードの状態を保持します。
*   ユーザーAが「保存」した後、さらに描画を続けた場合、その新しい描画操作は`drawing_elements`としてデータベースに永続化され、Action Cableでブロードキャストされますが、`canvas_data`にはまだ反映されていません。
*   この状態でユーザーBがボードに参加すると、`fetchDrawingData`は既存の`canvas_data`を読み込み、それ以降に描画された`drawing_elements`（ユーザーAの未保存の描画）は読み込まれません。

### 2.2. DrawingElement のリアルタイム処理とクリーンアップ

*   `app/controllers/api/v1/drawing_elements_controller.rb` の `create` および `update` アクションで、新しい `drawing_element` が作成または更新されると、Action Cable (`ActionCable.server.broadcast`) を通じて他のクライアントにリアルタイムで通知されます。
*   `app/channels/drawing_channel.rb` の `draw` メソッドも同様に、クライアントからの描画データを受信し、`drawing_element` を作成し、ブロードキャストしています。
*   `app/jobs/cleanup_drawing_elements_job.rb` は、`Drawing` が保存された際に、その `last_saved_at` よりも古い `drawing_elements` を削除します。これは、`canvas_data` に含まれるようになった描画要素をクリーンアップする目的ですが、今回の問題との関連性は以下の通りです。
    *   ユーザーAが保存を行い、その後も描画を続けている間に、新しい`drawing_elements`が生成されます。
    *   この時点では、新しく生成された`drawing_elements`はまだ`canvas_data`に含まれていません。
    *   ユーザーBがボードに参加すると、`canvas_data`が読み込まれますが、上記で生成された新しい`drawing_elements`は読み込まれず、結果として`canvas_data`のみの古い状態が表示されます。
    *   `CleanupDrawingElementsJob`は保存がトリガーされるため、上記の問題が発生している状況では、`drawing_elements`はまだ削除対象になっていません。しかし、このジョブが`canvas_data`更新後の不要な要素を削除するという目的を果たすためには、初期ロードで全ての最新状態を読み込むことが前提となります。

### 2.3. 問題の根本原因

*   **描画ボード初期ロード時のデータ取得の不完全性**:
    *   新規参加ユーザーは、明示的に保存された`canvas_data`は取得できますが、最後に保存されてから現在までに他のユーザーが行ったリアルタイムな描画操作（`drawing_elements`）を初期ロード時に取得できていません。
    *   Action Cableはリアルタイムな差分更新には優れていますが、ボードに参加した時点の「最新のスナップショット」を提供するメカニズムとしては不十分です。

以上の調査結果を踏まえ、次項で設計方針を検討します。

## 4. 実行計画

上記の設計書に基づき、以下のステップで実装を進めます。

### 4.1. バックエンド実装

1.  **描画ボード初期ロードAPIの修正**: `app/controllers/api/v1/drawings_controller.rb` の `show` アクションを拡張し、`Drawing` の `canvas_data` と、その `last_saved_at` 以降の `DrawingElement` をまとめて返すように変更します。
    *   `last_saved_at` が `nil` の場合は、全ての `DrawingElement` を返すようにします。
    *   対応する `app/views/api/v1/drawings/show.json.jbuilder` を修正します。
2.  **テストコードの追加/修正**: 上記APIの変更に伴い、`spec/requests/api/v1/drawings_spec.rb` にテストケースを追加または修正し、新しいAPIが期待通りに動作することを確認します。

### 4.2. フロントエンド実装

1.  **描画ボード初期ロードロジックの修正**: `frontend/src/pages/DrawingBoard.tsx` の `useEffect` 内の `fetchDrawingData` 関数を修正します。
    *   新しいバックエンドAPI (`/api/v1/drawings/:drawing_id`) を呼び出し、レスポンスから `canvas_data` と `drawing_elements_after_save` を取得します。
    *   `canvas_data` を基に `drawingElements` を初期化し、その後 `drawing_elements_after_save` を追加して描画ボードの最終状態を構築します。
    *   `setLastSavedAt` も適切に設定します。
2.  **テストコードの追加/修正**: `frontend/src/tests/pages/DrawingBoard.test.tsx` にテストケースを追加または修正し、新規参加ユーザーがボードの最新状態を正しくロードできることを確認します。

### 4.3. 結合テストと検証

1.  **複数ユーザーでの動作確認**: 複数のブラウザまたは匿名モードでボードを開き、以下のシナリオを検証します。
    *   ユーザーAが描画し、保存する。
    *   ユーザーAがさらに描画する（未保存の状態）。
    *   ユーザーBがボードに参加し、ユーザーAの未保存の描画を含め、ボードの最新状態が正確に表示されることを確認する。
    *   ユーザーBが描画した内容が、ユーザーAのボードにもリアルタイムで反映されることを確認する。
2.  **Edgeケースの確認**:
    *   一度も保存されていない新規ボードの場合の挙動。
    *   大量の描画要素がある場合のパフォーマンス。

この計画に沿って実装を進めていきます。
