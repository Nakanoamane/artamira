# リアルタイム描画同期機能設計書

## 1. 要件定義

### 1.1. 問題の再定義

ユーザーより以下の現象が報告されました。
1. ボードxにユーザーAが描画し、保存を行う
2. ボードxにユーザーAがさらに描画する
3. ボードxにユーザーBが参加する。このとき、**2の状態が表示されてほしいところが1のみ描画される**。

この結果、ユーザーAとユーザーBの間でボードの状態が異なる状態になってしまう。

### 1.2. 解決すべき要件

上記の現象を踏まえ、以下の要件を解決します。

*   **新規参加ユーザーの描画状態の完全な再現**:
    *   ユーザーが描画ボードに参加した際、その時点でのボードの最新状態（保存された`canvas_data`と、それ以降の未保存の`drawing_elements`の両方を含む）を正確に表示できること。
*   **リアルタイムコラボレーションの維持**:
    *   ボードに参加している全ユーザー間で、描画の変更がリアルタイムに同期されること。
*   **データの整合性と効率性の両立**:
    *   `canvas_data`と`drawing_elements`の適切な管理により、データの整合性を保ちつつ、データベースの肥大化を防ぐこと。
    *   特に、保存されていない新しい`drawing_elements`が誤って削除されないようにすること。
*   **Undo/Redo操作のリアルタイム同期**:
    *   いずれかのユーザーが行ったUndo/Redo操作が、ボードに参加している全てのユーザーにリアルタイムで反映され、描画状態が同期されること。

## 2. 調査

### 2.1. 現在の描画ボード初期ロードロジック

`frontend/src/pages/DrawingBoard.tsx` の `useEffect` 内で `fetchDrawingData` 関数がボードの初期ロードを行っています。

```javascript
  useEffect(() => {
    const fetchDrawingData = async () => {
      if (!drawingId) { /* ... */ }

      try {
        // Step 1: Try to fetch canvas_data from the new endpoint
        const response = await fetch(
          `${import.meta.env.VITE_API_URL}/api/v1/drawings/${drawingId}`,
          { /* ... */ }
        );

        // ... response handling ...

        const data = await response.json();

        if (data.canvas_data) {
          // If canvas_data exists, use it
          setDrawingElements(JSON.parse(data.canvas_data));
          setLastSavedAt(data.last_saved_at ? new Date(data.last_saved_at) : null);
          setIsDirty(false);
        } else {
          // If canvas_data does not exist, fetch drawing elements as fallback
          await fetchDrawingElementsFallback(drawingId);
        }
      } catch (e: any) { /* ... */ } finally { /* ... */ }
    };

    const fetchDrawingElementsFallback = async (id: number) => {
      try {
        const response = await fetch(
          `${import.meta.env.VITE_API_URL}/api/v1/drawings/${id}/elements`,
          { /* ... */ }
        );
        // ... response handling ...
        const data = await response.json();
        setDrawingElements(data.drawing_elements || []);
        setLastSavedAt(data.last_saved_at ? new Date(data.last_saved_at) : null);
        setIsDirty(false);
      } catch (e: any) { /* ... */ }
    };

    fetchDrawingData();
  }, [drawingId]);
```

このロジックの問題点は以下の通りです。

*   `canvas_data`が存在する場合、`drawing_elements`は**一切読み込まれません**。
*   `canvas_data`は、ユーザーが明示的に「保存」ボタンを押した時点でのボードの状態を保持します。
*   ユーザーAが「保存」した後、さらに描画を続けた場合、その新しい描画操作は`drawing_elements`としてデータベースに永続化され、Action Cableでブロードキャストされますが、`canvas_data`にはまだ反映されていません。
*   この状態でユーザーBがボードに参加すると、`fetchDrawingData`は既存の`canvas_data`を読み込み、それ以降に描画された`drawing_elements`（ユーザーAの未保存の描画）は読み込まれません。

### 2.2. DrawingElement のリアルタイム処理とクリーンアップ

*   `app/controllers/api/v1/drawing_elements_controller.rb` の `create` アクションで、新しい `drawing_element` が作成されると、Action Cable (`ActionCable.server.broadcast`) を通じて他のクライアントにリアルタイムで通知されます。
*   `app/channels/drawing_channel.rb` の `draw` メソッドも同様に、クライアントからの描画データを受信し、`drawing_element` を作成し、ブロードキャストしています。
*   `app/jobs/cleanup_drawing_elements_job.rb` は、`Drawing` が保存された際に、その `last_saved_at` よりも古い `drawing_elements` を削除します。これは、`canvas_data` に含まれるようになった描画要素をクリーンアップする目的ですが、今回の問題との関連性は以下の通りです。
    *   ユーザーAが保存を行い、その後も描画を続けている間に、新しい`drawing_elements`が生成されます。
    *   この時点では、新しく生成された`drawing_elements`はまだ`canvas_data`に含まれていません。
    *   ユーザーBがボードに参加すると、`canvas_data`が読み込まれますが、上記で生成された新しい`drawing_elements`は読み込まれず、結果として`canvas_data`のみの古い状態が表示されます。
    *   `CleanupDrawingElementsJob`は保存がトリガーされるため、上記の問題が発生している状況では、`drawing_elements`はまだ削除対象になっていません。しかし、このジョブが`canvas_data`更新後の不要な要素を削除するという目的を果たすためには、初期ロードで全ての最新状態を読み込むことが前提となります。

### 2.3. 問題の根本原因

*   **描画ボード初期ロード時のデータ取得の不完全性**:
    *   新規参加ユーザーは、明示的に保存された`canvas_data`は取得できますが、最後に保存されてから現在までに他のユーザーが行ったリアルタイムな描画操作（`drawing_elements`）を初期ロード時に取得できていません。
    *   Action Cableはリアルタイムな差分更新には優れていますが、ボードに参加した時点の「最新のスナップショット」を提供するメカニズムとしては不十分です。
*   **Undo/Redo操作の非同期性**:
    *   現在、Undo/Redo操作は各ユーザーのローカルな`drawingElements`ステートのみを変更しており、Action Cableを介して他のコラボレーターに同期されていません。このため、あるユーザーがUndo/Redoを実行しても、他のユーザーのボードには反映されず、描画状態に差異が生じます。

以上の調査結果を踏まえ、次項で設計方針を検討します。

## 3. 設計

### 3.1. バックエンド設計

1.  **描画ボード初期ロードAPI (`GET /api/v1/drawings/:id`)**: `app/controllers/api/v1/drawings_controller.rb` の `show` アクションを拡張し、`Drawing` の `canvas_data` と、その `last_saved_at` 以降の `DrawingElement` をまとめて返します。
    *   `last_saved_at` が `nil` の場合は、全ての `DrawingElement` を返します。
    *   対応する `app/views/api/v1/drawings/show.json.jbuilder` を修正します。
2.  **Action Cableアクションの追加 (`DrawingChannel`)**: `app/channels/drawing_channel.rb` に以下のAction Cableアクションを追加します。
    *   `undo_action`: Undo操作をブロードキャストするためのアクション。引数として、Undo後の`drawing_elements`の完全な配列を受け取り、これを`drawing_elements_updated`イベントとして他のクライアントにブロードキャストします。
    *   `redo_action`: Redo操作をブロードキャストするためのアクション。引数として、Redo後の`drawing_elements`の完全な配列を受け取り、これを`drawing_elements_updated`イベントとして他のクライアントにブロードキャストします。

### 3.2. フロントエンド設計

1.  **描画ボード初期ロードロジック (`frontend/src/pages/DrawingBoard.tsx`)**: `useEffect` 内の `fetchDrawingData` 関数を修正します。
    *   新しいバックエンドAPI (`/api/v1/drawings/:drawing_id`) を呼び出し、レスポンスから `canvas_data` と `drawing_elements_after_save` を取得します。
    *   `canvas_data` を基に `drawingElements` を初期化し、その後 `drawing_elements_after_save` を追加して描画ボードの最終状態を構築します。
    *   `setLastSavedAt` も適切に設定します。
2.  **Undo操作のブロードキャスト (`handleUndo`)**: `frontend/src/pages/DrawingBoard.tsx` の `handleUndo` 関数を修正し、Undo操作によって更新された`drawingElements`の配列全体をAction Cableを通じてブロードキャストするようにします。
    *   Action Cableへの送信フォーマット: `{ type: 'undo_action', drawing_elements: currentDrawingElementsArray }` (Undo後の状態)
3.  **Redo操作のブロードキャスト (`handleRedo`)**: `frontend/src/pages/DrawingBoard.tsx` の `handleRedo` 関数を修正し、Redo操作によって更新された`drawingElements`の配列全体をAction Cableを通じてブロードキャストするようにします。
    *   Action Cableへの送信フォーマット: `{ type: 'redo_action', drawing_elements: currentDrawingElementsArray }` (Redo後の状態)
4.  **Action Cable経由でのUndo/Redo受信処理 (`handleReceivedData`)**: `frontend/src/pages/DrawingBoard.tsx` の `handleReceivedData` 関数に、Action Cableから受信したUndo/Redoイベントを処理するロジックを追加します。
    *   `type: 'undo_action'` または `type: 'redo_action'` イベントを受信した場合、受信した `drawing_elements` 配列を自身の`drawingElements`ステートに直接反映させます。
    *   他のユーザーからのUndo/Redo操作により`drawingElements`が変更された場合、自身のローカルな`undoStack`と`redoStack`はクリアします。これにより、ローカルの履歴とリモートの履歴の整合性の問題を簡素化します。

## 4. 実行計画

上記の設計書に基づき、以下のステップで実装を進めます。

### 4.1. バックエンド実装

1.  **描画ボード初期ロードAPIの修正**: `app/controllers/api/v1/drawings_controller.rb` の `show` アクションを拡張し、`Drawing` の `canvas_data` と、その `last_saved_at` 以降の `DrawingElement` をまとめて返すように変更します。
    *   `last_saved_at` が `nil` の場合は、全ての `DrawingElement` を返すようにします。
    *   対応する `app/views/api/v1/drawings/show.json.jbuilder` を修正します。
2.  **Action Cable Undo/Redoアクションの追加**: Action Cableを通じてUndo/Redo操作をブロードキャストするための新しいアクション（`undo_action`, `redo_action`）を `app/channels/drawing_channel.rb` に追加します。これらのアクションは、Undo/Redo後の`drawing_elements`の状態を通知できるように設計します。
3.  **テストコードの追加/修正**: 上記APIおよびAction Cableの変更に伴い、`spec/requests/api/v1/drawings_spec.rb` や `spec/channels/drawing_channel_spec.rb` にテストケースを追加または修正し、新しいAPIが期待通りに動作することを確認します。

### 4.2. フロントエンド実装

1.  **描画ボード初期ロードロジックの修正**: `frontend/src/pages/DrawingBoard.tsx` の `useEffect` 内の `fetchDrawingData` 関数を修正します。
    *   新しいバックエンドAPI (`/api/v1/drawings/:drawing_id`) を呼び出し、レスポンスから `canvas_data` と `drawing_elements_after_save` を取得します。
    *   `canvas_data` を基に `drawingElements` を初期化し、その後 `drawing_elements_after_save` を追加して描画ボードの最終状態を構築します。
    *   `setLastSavedAt` も適切に設定します。
2.  **Undo/Redo操作のブロードキャスト**: `frontend/src/pages/DrawingBoard.tsx` の `handleUndo` および `handleRedo` 関数を修正し、Action Cableを通じて対応するイベントをブロードキャストするようにします。
3.  **Action Cable経由でのUndo/Redo受信処理**: `frontend/src/pages/DrawingBoard.tsx` の `handleReceivedData` 関数に、Action Cableから受信したUndo/Redoイベントを処理するロジックを追加します。これにより、他のユーザーのUndo/Redo操作が自身のボードに反映されるようにします。
4.  **テストコードの追加/修正**: `frontend/src/tests/pages/DrawingBoard.test.tsx` にテストケースを追加または修正し、新規参加ユーザーがボードの最新状態を正しくロードできること、およびUndo/Redo操作がリアルタイムで同期されることを確認します。

### 4.3. 結合テストと検証

1.  **複数ユーザーでの動作確認**: 複数のブラウザまたは匿名モードでボードを開き、以下のシナリオを検証します。
    *   ユーザーAが描画し、保存する。
    *   ユーザーAがさらに描画する（未保存の状態）。
    *   ユーザーBがボードに参加し、ユーザーAの未保存の描画を含め、ボードの最新状態が正確に表示されることを確認する。
    *   ユーザーBが描画した内容が、ユーザーAのボードにもリアルタイムで反映されることを確認する。
    *   ユーザーAがUndo/Redo操作を行った際、ユーザーBのボードにもその変更がリアルタイムで反映されることを確認する。
2.  **Edgeケースの確認**:
    *   一度も保存されていない新規ボードの場合の挙動。
    *   大量の描画要素がある場合のパフォーマンス。

この計画に沿って実装を進めていきます。
