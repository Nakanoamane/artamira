# リアルタイム描画同期機能設計書

## 1. 要件定義

### 1.1. 問題の再定義

ユーザーより以下の現象が報告されました。
1. ボードxにユーザーAが描画し、保存を行う
2. ボードxにユーザーAがさらに描画する
3. ボードxにユーザーBが参加する。このとき、**2の状態が表示されてほしいところが1のみ描画される**。

この結果、ユーザーAとユーザーBの間でボードの状態が異なる状態になってしまう。

### 1.2. 解決すべき要件

上記の現象を踏まえ、以下の要件を解決します。

*   **新規参加ユーザーの描画状態の完全な再現**:
    *   ユーザーが描画ボードに参加した際、その時点でのボードの最新状態（保存された`canvas_data`と、それ以降の未保存の`drawing_elements`の両方を含む）を正確に表示できること。
*   **リアルタイムコラボレーションの維持**:
    *   ボードに参加している全ユーザー間で、描画の変更がリアルタイムに同期されること。
*   **データの整合性と効率性の両立**:
    *   `canvas_data`と`drawing_elements`の適切な管理により、データの整合性を保ちつつ、データベースの肥大化を防ぐこと。
    *   特に、保存されていない新しい`drawing_elements`が誤って削除されないようにすること。
*   **Undo/Redo操作のリアルタイム同期**:
    *   いずれかのユーザーが行ったUndo/Redo操作が、ボードに参加している全てのユーザーにリアルタイムで反映され、描画状態が同期されること。

## 2. 調査

### 2.1. 現在の描画ボード初期ロードロジック

`frontend/src/pages/DrawingBoard.tsx` の `useEffect` 内で `fetchDrawingData` 関数がボードの初期ロードを行っています。

```javascript
  useEffect(() => {
    const fetchDrawingData = async () => {
      if (!drawingId) { /* ... */ }

      try {
        // Step 1: Try to fetch canvas_data from the new endpoint
        const response = await fetch(
          `${import.meta.env.VITE_API_URL}/api/v1/drawings/${drawingId}`,
          { /* ... */ }
        );

        // ... response handling ...

        const data = await response.json();

        if (data.canvas_data) {
          // If canvas_data exists, use it
          setDrawingElements(JSON.parse(data.canvas_data));
          setLastSavedAt(data.last_saved_at ? new Date(data.last_saved_at) : null);
          setIsDirty(false);
        } else {
          // If canvas_data does not exist, fetch drawing elements as fallback
          await fetchDrawingElementsFallback(drawingId);
        }
      } catch (e: any) { /* ... */ } finally { /* ... */ }
    };

    const fetchDrawingElementsFallback = async (id: number) => {
      try {
        const response = await fetch(
          `${import.meta.env.VITE_API_URL}/api/v1/drawings/${id}/elements`,
          { /* ... */ }
        );
        // ... response handling ...
        const data = await response.json();
        setDrawingElements(data.drawing_elements || []);
        setLastSavedAt(data.last_saved_at ? new Date(data.last_saved_at) : null);
        setIsDirty(false);
      } catch (e: any) { /* ... */ }
    };

    fetchDrawingData();
  }, [drawingId]);
```

このロジックの問題点は以下の通りです。

*   `canvas_data`が存在する場合、`drawing_elements`は**一切読み込まれません**。
*   `canvas_data`は、ユーザーが明示的に「保存」ボタンを押した時点でのボードの状態を保持します。
*   ユーザーAが「保存」した後、さらに描画を続けた場合、その新しい描画操作は`drawing_elements`としてデータベースに永続化され、Action Cableでブロードキャストされますが、`canvas_data`にはまだ反映されていません。
*   この状態でユーザーBがボードに参加すると、`fetchDrawingData`は既存の`canvas_data`を読み込み、それ以降に描画された`drawing_elements`（ユーザーAの未保存の描画）は読み込まれません。

### 2.2. DrawingElement のリアルタイム処理とクリーンアップ

*   `app/controllers/api/v1/drawing_elements_controller.rb` の `create` アクションで、新しい `drawing_element` が作成されると、Action Cable (`ActionCable.server.broadcast`) を通じて他のクライアントにリアルタイムで通知されます。
*   `app/channels/drawing_channel.rb` の `draw` メソッドも同様に、クライアントからの描画データを受信し、`drawing_element` を作成し、ブロードキャストしています。
*   `app/jobs/cleanup_drawing_elements_job.rb` は、`Drawing` が保存された際に、その `last_saved_at` よりも古い `drawing_elements` を削除します。これは、`canvas_data` に含まれるようになった描画要素をクリーンアップする目的ですが、今回の問題との関連性は以下の通りです。
    *   ユーザーAが保存を行い、その後も描画を続けている間に、新しい`drawing_elements`が生成されます。
    *   この時点では、新しく生成された`drawing_elements`はまだ`canvas_data`に含まれていません。
    *   ユーザーBがボードに参加すると、`canvas_data`が読み込まれますが、上記で生成された新しい`drawing_elements`は読み込まれず、結果として`canvas_data`のみの古い状態が表示されます。
    *   `CleanupDrawingElementsJob`は保存がトリガーされるため、上記の問題が発生している状況では、`drawing_elements`はまだ削除対象になっていません。しかし、このジョブが`canvas_data`更新後の不要な要素を削除するという目的を果たすためには、初期ロードで全ての最新状態を読み込むことが前提となります。

### 2.3. 問題の根本原因

*   **描画ボード初期ロード時のデータ取得の不完全性**:
    *   新規参加ユーザーは、明示的に保存された`canvas_data`は取得できますが、最後に保存されてから現在までに他のユーザーが行ったリアルタイムな描画操作（`drawing_elements`）を初期ロード時に取得できていません。
    *   Action Cableはリアルタイムな差分更新には優れていますが、ボードに参加した時点の「最新のスナップショット」を提供するメカニズムとしては不十分です。
*   **Undo/Redo操作の非同期性**:
    *   現在、Undo/Redo操作は各ユーザーのローカルな`drawingElements`ステートのみを変更しており、Action Cableを介して他のコラボレーターに同期されていません。このため、あるユーザーがUndo/Redoを実行しても、他のユーザーのボードには反映されず、描画状態に差異が生じます。

以上の調査結果を踏まえ、次項で設計方針を検討します。

## 3. 設計

### 3.1. バックエンド設計

1.  **描画ボード初期ロードAPI (`GET /api/v1/drawings/:id`)**: `app/controllers/api/v1/drawings_controller.rb` の `show` アクションを拡張し、`Drawing` の `canvas_data` と、その `last_saved_at` 以降の `DrawingElement` をまとめて返します。
    *   `last_saved_at` が `nil` の場合は、全ての `DrawingElement` を返します。
    *   対応する `app/views/api/v1/drawings/show.json.jbuilder` を修正します。
2.  **Action Cableアクションの追加 (`DrawingChannel`)**: `app/channels/drawing_channel.rb` に以下のAction Cableアクションを追加します。
    *   `update_element_status`: 特定の `drawing_element` の `is_active` 状態の変更をブロードキャストするためのアクション。引数として、変更された`element_id`と`is_active`の状態を受け取り、これを`drawing_element_status_changed`イベントとして他のクライアントにブロードキャストします。
        *   **補足**: この操作は、Undo/Redoによって特定の描画要素の表示/非表示状態が変更されたことを示すものです。

### 3.2. フロントエンド設計

1.  **描画ボード初期ロードロジック (`frontend/src/pages/DrawingBoard.tsx`)**: `useEffect` 内の `fetchDrawingData` 関数を修正します。
    *   新しいバックエンドAPI (`/api/v1/drawings/:drawing_id`) を呼び出し、レスポンスから `canvas_data` と `drawing_elements_after_save` を取得します。
    *   `canvas_data` を基に `drawingElements` を初期化し、その後 `drawing_elements_after_save` を追加して描画ボードの最終状態を構築します。
    *   `setLastSavedAt` も適切に設定します。
2.  **Undo操作のブロードキャスト (`handleUndo`)**: `frontend/src/pages/DrawingBoard.tsx` の `handleUndo` 関数を修正し、Undo操作によってアクティブ状態が変更された`drawingElements`の情報をAction Cableを通じてブロードキャストするようにします。
    *   Action Cableへの送信フォーマット: `{ type: 'update_element_status', element_id: '...', is_active: false }` (非アクティブになった要素のIDと状態)
    *   **補足**: 複数の要素が同時にUndoされる場合は、それぞれの要素の変更を個別に、または配列としてまとめて送信することを検討します。
3.  **Redo操作のブロードキャスト (`handleRedo`)**: `frontend/src/pages/DrawingBoard.tsx` の `handleRedo` 関数を修正し、Redo操作によってアクティブ状態が変更された`drawingElements`の情報をAction Cableを通じてブロードキャストするようにします。
    *   Action Cableへの送信フォーマット: `{ type: 'update_element_status', element_id: '...', is_active: true }` (アクティブになった要素のIDと状態)
    *   **補足**: 複数の要素が同時にRedoされる場合は、それぞれの要素の変更を個別に、または配列としてまとめて送信することを検討します。
4.  **Action Cable経由でのUndo/Redo受信処理 (`handleReceivedData`)**: `frontend/src/pages/DrawingBoard.tsx` の `handleReceivedData` 関数に、Action Cableから受信したUndo/Redoイベントを処理するロジックを追加します。
    *   `type: 'drawing_element_status_changed'` イベントを受信した場合、受信した `element_id` と `is_active` に基づいて、自身の`drawingElements`ステート内の対応する要素の`is_active`フラグを更新します。
    *   他のユーザーからのUndo/Redo操作により`drawingElements`が変更された場合、自身のローカルな`undoStack`と`redoStack`はクリアします。これにより、ローカルの履歴とリモートの履歴の整合性の問題を簡素化します。

## 4. 実行計画

上記の設計書に基づき、以下のステップで実装を進めます。

### 4.1. バックエンド実装

1.  **描画ボード初期ロードAPIの修正**: `app/controllers/api/v1/drawings_controller.rb` の `show` アクションを拡張し、`Drawing` の `canvas_data` と、その `last_saved_at` 以降の `DrawingElement` をまとめて返すように変更します。
    *   `last_saved_at` が `nil` の場合は、全ての `DrawingElement` を返すようにします。
    *   対応する `app/views/api/v1/drawings/show.json.jbuilder` を修正します。
2.  **Action Cable Undo/Redoアクションの追加**: `app/channels/drawing_channel.rb` に `update_element_status` アクションを追加し、特定の `drawing_element` の `is_active` 状態の変更を通知できるように設計します。また、`DrawingElement` モデルに `is_active:boolean` カラムを追加するマイグレーションを行います。
3.  **テストコードの追加/修正**: 上記APIおよびAction Cableの変更に伴い、`spec/requests/api/v1/drawings_spec.rb` や `spec/channels/drawing_channel_spec.rb` にテストケースを追加または修正し、新しいAPIが期待通りに動作することを確認します。

### 4.2. フロントエンド実装

1.  **描画ボード初期ロードロジックの修正**: `frontend/src/pages/DrawingBoard.tsx` の `useEffect` 内の `fetchDrawingData` 関数を修正します。
    *   新しいバックエンドAPI (`/api/v1/drawings/:drawing_id`) を呼び出し、レスポンスから `canvas_data` と `drawing_elements_after_save` を取得します。
    *   `canvas_data` を基に `drawingElements` を初期化し、その後 `drawing_elements_after_save` を追加して描画ボードの最終状態を構築します。
    *   `setLastSavedAt` も適切に設定します。
2.  **Undo/Redo操作のブロードキャスト**: `frontend/src/pages/DrawingBoard.tsx` の `handleUndo` および `handleRedo` 関数を修正し、Action Cableを通じて `drawing_element` の `is_active` 状態変更イベントをブロードキャストするようにします。
3.  **Action Cable経由でのUndo/Redo受信処理**: `frontend/src/pages/DrawingBoard.tsx` の `handleReceivedData` 関数に、Action Cableから受信した `drawing_element_status_changed` イベントを処理するロジックを追加します。これにより、他のユーザーのUndo/Redo操作が自身のボードに反映されるようにします。
4.  **テストコードの追加/修正**: `frontend/src/tests/pages/DrawingBoard.test.tsx` にテストケースを追加または修正し、新規参加ユーザーがボードの最新状態を正しくロードできること、およびUndo/Redo操作がリアルタイムで同期されることを確認します。

### 4.3. 結合テストと検証

1.  **複数ユーザーでの動作確認**: 複数のブラウザまたは匿名モードでボードを開き、以下のシナリオを検証します。
    *   ユーザーAが描画し、保存する。
    *   ユーザーAがさらに描画する（未保存の状態）。
    *   ユーザーBがボードに参加し、ユーザーAの未保存の描画を含め、ボードの最新状態が正確に表示されることを確認する。
    *   ユーザーBが描画した内容が、ユーザーAのボードにもリアルタイムで反映されることを確認する。
    *   ユーザーAがUndo/Redo操作を行った際、ユーザーBのボードにもその変更がリアルタイムで反映されることを確認する。
2.  **Edgeケースの確認**:
    *   一度も保存されていない新規ボードの場合の挙動。
    *   大量の描画要素がある場合のパフォーマンス。

この計画に沿って実装を進めていきます。

## 5. 次回予告

承知いたしました。次回、Undo/Redo機能の改修をAIに依頼する際の準備として、以下の内容をまとめます。

---

### Undo/Redo機能改修のための準備

#### 1. 設計書の更新について

Undo/Redo機能に関する設計書 (`docs/design/リアルタイム描画同期機能設計書.md`) は、先日議論した内容（`is_active` フラグによる差分更新、およびそのブロードキャスト）を反映して既に更新済みです。この設計書をベースに改修を進めます。

#### 2. 設計書の内容と現在の実装の比較・差分リストアップ

現在の`frontend/src/pages/DrawingBoard.tsx`と`app/channels/drawing_channel.rb`の実装を、新しい設計書の内容と比較し、差分をリストアップします。

**バックエンド側 (`app/channels/drawing_channel.rb` および関連モデル)**

*   **差分1: `DrawingElement` モデルへの `is_active` カラム追加**:
    *   **設計**: `DrawingElement` モデルに `is_active:boolean` カラムを追加するマイグレーションが必要です。デフォルト値は `true` とします。
    *   **現状**: `is_active` カラムは存在しません。
*   **差分2: Action Cable `update_element_status` アクションの追加**:
    *   **設計**: `app/channels/drawing_channel.rb` に `update_element_status` という新しいAction Cableアクションを追加します。このアクションは、クライアントから `element_id` と `is_active` の状態を受け取り、該当する `DrawingElement` の `is_active` フラグをデータベースで更新し、その変更を他のクライアントにブロードキャストするように設計されています。
    *   **現状**: `draw` アクションは存在しますが、`update_element_status` アクションは存在しません。
*   **差分3: 初期ロードAPI (`GET /api/v1/drawings/:id`) の修正**:
    *   **設計**: `app/controllers/api/v1/drawings_controller.rb` の `show` アクションで、`canvas_data` と `drawing_elements_after_save` を返す際に、`drawing_elements_after_save` に `is_active` フラグを含める、または `is_active: true` の要素のみを返すように考慮する必要があります。
    *   **現状**: `drawing_elements_after_save` は `is_active` フラグを考慮していません。

**フロントエンド側 (`frontend/src/pages/DrawingBoard.tsx`)**

*   **差分1: `handleUndo` 関数の修正**:
    *   **設計**: Undo操作によって非アクティブになる `drawingElements` の要素（または要素群）のIDと `is_active: false` の状態をAction Cableを通じてブロードキャストするように修正します。
    *   **現状**: 現在は `drawingElements` の状態を `redoStack` に保存し、`drawingElements` を `undoStack` から取得した過去の状態に戻すのみで、Action Cableによるブロードキャストは行っていません。
*   **差分2: `handleRedo` 関数の修正**:
    *   **設計**: Redo操作によってアクティブになる `drawingElements` の要素（または要素群）のIDと `is_active: true` の状態をAction Cableを通じてブロードキャストするように修正します。
    *   **現状**: 現在は `drawingElements` の状態を `undoStack` に保存し、`drawingElements` を `redoStack` から取得した未来の状態に進めるのみで、Action Cableによるブロードキャストは行っていません。
*   **差分3: `handleReceivedData` 関数の修正**:
    *   **設計**: Action Cableから `type: 'drawing_element_status_changed'` イベントを受信した場合、受信した `element_id` と `is_active` に基づいて、自身の `drawingElements` ステート内の対応する要素の `is_active` フラグを更新するロジックを追加します。また、他のユーザーからのUndo/Redo操作により `drawingElements` が変更された場合、自身のローカルな `undoStack` と `redoStack` をクリアする処理を追加します。
    *   **現状**: `drawing_element_created` と `drawing_saved` イベントのみを処理しており、Undo/Redoに関するAction Cableイベントの処理ロジックはありません。
*   **差分4: `fetchDrawingData` 関数の修正**:
    *   **設計**: バックエンドから取得する `drawing_elements_after_save` データに `is_active` フラグが含まれるようになるため、そのフラグを考慮して `drawingElements` を初期化するロジック（`is_active: true` の要素のみを描画対象とする）が必要になります。
    *   **現状**: `is_active` フラグを考慮していません。
*   **差分5: `Canvas` コンポーネントの修正 (可能性あり)**:
    *   **設計**: `drawingElements` の中に `is_active: false` の要素が含まれるようになった場合、`Canvas` コンポーネントが描画時に `is_active: true` の要素のみをレンダリングするように変更が必要です。
    *   **現状**: 全ての `drawingElements` を描画しています。

#### 3. 改修内容のまとめ

上記の差分に基づき、Undo/Redo機能の改修内容は以下の通りです。

1.  **バックエンド**:
    *   `DrawingElement` モデルに `is_active:boolean` カラムを追加するマイグレーションを作成・実行します。
    *   `app/channels/drawing_channel.rb` に `update_element_status` Action Cableアクションを追加し、`element_id` と `is_active` を受け取ってデータベースを更新し、ブロードキャストするように実装します。
    *   `app/controllers/api/v1/drawings_controller.rb` の `show` アクションで、`drawing_elements_after_save` を返す際に `is_active` フラグを適切に扱い、クライアントが最新の状態を正確に再構築できるようサポートします。
    *   関連するテストコードを追加・修正します。
2.  **フロントエンド**:
    *   `frontend/src/pages/DrawingBoard.tsx` の `handleUndo` および `handleRedo` 関数を修正し、Undo/Redo操作によって状態が変更された要素の `element_id` と `is_active` の状態をAction Cableを通じてブロードキャストするようにします。
    *   `frontend/src/pages/DrawingBoard.tsx` の `handleReceivedData` 関数に、`drawing_element_status_changed` イベントを処理するロジックを追加します。このロジックは、受信した情報に基づいて自身の `drawingElements` ステート内の対応する要素の `is_active` フラグを更新します。
    *   `handleReceivedData` 内で、他のユーザーからのUndo/Redo操作により `drawingElements` が変更された場合、自身のローカルな `undoStack` と `redoStack` をクリアする処理を実装します。
    *   `frontend/src/pages/DrawingBoard.tsx` の `fetchDrawingData` 関数で、初期ロード時に取得する `drawing_elements_after_save` を処理する際に、`is_active` フラグを考慮して `drawingElements` を設定します。
    *   `frontend/src/components/Canvas.tsx` コンポーネントが `drawingElements` を描画する際、`is_active: true` の要素のみをレンダリングするように修正します。
    *   関連するテストコードを追加・修正します。

#### 4. 実装の開始

上記の改修内容がまとまりましたので、次回この指示を受け取った際には、実装を開始します。
