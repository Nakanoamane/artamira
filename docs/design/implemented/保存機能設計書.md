# 保存機能設計書

## 概要
本設計書は、Artamiraにおける描画内容の保存、読み込み、ページ離脱時の警告、およびエクスポート機能の実装について詳述する。
本稿では、特に既存の保存機能が抱える問題点を解決し、リアルタイム描画と明確な保存を両立する新保存機能の設計について記述する。

## 現在の保存機能における本質的な問題点

本プロジェクトの既存の保存機能には、以下の根本的な問題が存在します。

1.  **「保存」の定義の曖昧さと機能の重複**:
    *   Action Cableを通じて描画が行われるたびに`drawing_elements`が作成され、リアルタイムでデータベースに永続化されています。これは実質的に「自動保存」のような状態です。
    *   しかし、UI上の「保存ボタン」を押しても、実際には`Drawing`モデルの`last_saved_at`タイムスタンプが更新されるだけで、描画データ自体の「保存」は行われません。
    *   この結果、「リアルタイム永続化」と「明示的な保存」という二つの異なる保存概念が混在し、ユーザーにとって「保存」が何を意味するのか不明確になっています。

2.  **`drawing_elements`の肥大化によるパフォーマンスとスケーラビリティの問題**:
    *   描画のストローク（線や図形など）ごとに新しい`DrawingElement`が作成されるため、ユーザーが描画を続けると`drawing_elements`テーブルのレコード数が無限に増え続けます。
    *   これにより、データベースの容量が増大するだけでなく、既存の描画を読み込む際に大量の要素をデータベースから取得し、フロントエンドでレンダリングする必要が生じるため、パフォーマンスが著しく低下する懸念があります。現状では、これらの要素を効率的に管理したり、統合したりする仕組みが欠如しています。

3.  **描画状態の再現性の欠如**:
    *   既存の描画ボードにアクセスした際に、これまで描画した内容が提供されず、白紙で始まってしまう問題は、上記1と2の直接的な結果です。
    *   個々の`drawing_elements`はデータベースに存在しますが、それらを結合して「一枚の完成された描画」として正確に再構築し、フロントエンドに提供するメカニズム、またはそのメカニズムが正しく機能していない可能性があります。つまり、個々の描画イベントは保存されていますが、描画全体の「最終状態」が効率的に保存・読み込みされていないことが問題です。

これらの問題は、リアルタイムコラボレーションと永続化の設計が十分に統合されておらず、結果としてデータの冗長性、パフォーマンスの低下、そしてユーザー体験の劣化を引き起こしています。

## 新保存機能設計

### 1. ユーザーにとっての「保存」の明確化

現在のArtamiraにおける「保存」は、ユーザーの視点から見ると非常に曖昧な状態です。描画操作ごとのリアルタイム永続化と、UI上の「保存ボタン」による`last_saved_at`の更新が混在し、ユーザーは「既に保存されているのに、なぜまた保存するのか？」「保存したはずなのに、なぜボードを開くと白紙なのか？」といった混乱を招いています。

新保存機能では、ユーザーにとっての「保存」を「**作業を中断しても、後でまったく同じ状態から再開できる、確定された描画の最終状態を永続化すること**」と明確に定義します。リアルタイムな変更は共同編集者との共有を目的とした一時的な永続化とし、明示的な「保存」によってのみ、描画ボードの確定された最終状態が記録されるようにします。

### 2. 採用する改善案

複数の改善案を比較検討した結果、「**リアルタイム永続化」＋「明示的な最終状態保存」＋「定期的なクリーンアップ**」を採用します。この案は、以下の理由により最もバランスが良く、現在の問題点を効果的に解決できると判断しました。

*   **リアルタイム性とデータ保全の両立**: リアルタイムコラボレーションの利便性（他のユーザーへの即時反映、予期せぬ中断時のデータ喪失リスク低減）を維持しつつ、明示的な保存によって確定された状態を確実に再現できます。
*   **パフォーマンスの改善とスケーラビリティ**: `DrawingElement`の無限増殖を防ぎ、データベースの肥大化を抑制します。ボード読み込み時には、最新の`canvas_data`を読み込むことで高速な表示が可能です。
*   **「保存」の明確化**: ユーザーが「保存」ボタンを押すことで、その時点での作業内容が「確定された最新の状態」として保存されることが明確になります。

### 3. 新保存機能の解説（既存実装・設計との違い）

新しい保存機能は、既存の実装・設計に対し、以下の重要な変更と追加を行います。

*   **`Drawing`モデルの変更**:
    *   **カラム追加**: `canvas_data` (`TEXT` or `JSONB`, `NULL: true`): 明示的な「保存」が行われた時点のキャンバス全体の描画状態（シリアライズされた形式）を保存します。これにより、個々の`DrawingElement`を再構築することなく、直接最終状態を読み込めるようになります。

*   **描画保存APIの変更**:
    *   既存の`/api/v1/drawings/:drawing_id/save`エンドポイントを変更します。
    *   リクエストボディに、フロントエンドから送信される現在のキャンバスの統合された描画データ（`canvas_data`）を含めます。
    *   サーバーサイドでは、この`canvas_data`と`last_saved_at`を`Drawing`モデルに保存（更新）します。

*   **`DrawingElement`の役割と管理の変更**:
    *   **役割**: `DrawingElement`は、引き続きAction Cable経由でのリアルタイム描画データ共有（一時的な永続化）として利用します。これにより、共同編集時のリアルタイムな変更が他のユーザーにも即座に反映されます。
    *   **クリーンアップ**: 明示的な「保存」が行われ、`canvas_data`が更新された後、その保存時点より古い（かつ統合済みの）`DrawingElement`は、非同期ジョブなどで定期的にデータベースから削除するメカニズムを導入します。これにより、`drawing_elements`テーブルの肥大化を防ぎます。

*   **描画ボード読み込みロジックの変更**:
    *   描画ボードを開く際、まず`Drawing`モデルから`canvas_data`を読み込みます。
    *   `canvas_data`が存在する場合は、そのデータを使用してキャンバスを描画し、初期状態とします。これにより、「白紙で始まる」問題が解消され、読み込みも高速化されます。
    *   `canvas_data`が存在しない場合（例: 初めての描画ボード、またはまだ一度も明示的に保存されていない場合）は、既存の`DrawingElement`を読み込んで描画を再構築します。

*   **フロントエンドの「保存」処理の変更**:
    *   「保存」ボタンがクリックされた際、フロントエンド（`DrawingBoardPage.tsx`など）は、現在のキャンバスの描画状態を適切な形式でシリアライズ（例: 全ての描画要素をSVGパスに変換、または独自のJSON形式に変換）し、新しい保存APIに送信します。
    *   保存成功後、`last_saved_at`を更新し、`isDirty`フラグを`false`にリセットします。

この新しい設計により、リアルタイム描画の利便性を維持しつつ、ユーザーの意図する「保存」を実現し、パフォーマンスとスケーラビリティの問題も解決します。

### データベース設計

#### `Drawing` モデル
- **カラム追加/変更**:
    - `last_saved_at`: `DATETIME`, `NULL: true` (描画の最終保存日時。未保存の変更を検知するために使用。)
    - `canvas_data`: `TEXT` or `JSONB`, `NULL: true` (明示的な「保存」が行われた時点のキャンバス全体の描画状態をシリアライズされた形式で保存する。)
- **変更理由**: 明確な保存機能と描画状態の再現性を確立するため。

#### `DrawingElement` モデル
- **変更なし**: 既存の`drawing_id`, `user_id`, `element_type`, `data`カラムでリアルタイム描画要素の共有に十分対応可能。
- **`data`カラムのスキーマ (JSONB)**: 線の座標だけでなく、将来的な図形やテキスト要素にも対応できるよう、柔軟な構造を維持する。
- **補足**: `DrawingElement`はリアルタイムでの描画イベントのブロードキャストおよび一時的な永続化にのみ使用し、明示的な保存後は定期的なクリーンアップの対象とする。

### API設計

#### 1. 描画保存API

- **目的**: 描画内容をデータベースに明示的に保存する。
- **HTTPメソッド**: `POST`
- **パス**: `/api/v1/drawings/:drawing_id/save`
- **リクエスト**:
    - `drawing_id` (URLパラメータ): 保存対象の描画ボードのID。
    - リクエストボディに、フロントエンドから送信される現在のキャンバスの統合された描画データ（`canvas_data`）を含める。
    - 例:
        ```json
        {
            "canvas_data": "..."
        }
        ```
- **レスポンス**:
    - 成功時: `HTTP 200 OK`
        ```json
        {
            "status": "success",
            "message": "Drawing saved successfully.",
            "last_saved_at": "2023-10-27T10:00:00Z"
        }
        ```
    - 失敗時: `HTTP 400 Bad Request` または `HTTP 500 Internal Server Error`

#### 2. 描画読み込みAPI

- **目的**: 描画ボードの確定された最終状態を取得する。
- **HTTPメソッド**: `GET`
- **パス**: `/api/v1/drawings/:drawing_id`
- **リクエスト**:
    - `drawing_id` (URLパラメータ): 読み込み対象の描画ボードのID。
- **レスポンス**:
    - 成功時: `HTTP 200 OK`
        ```json
        {
            "drawing_id": 1,
            "canvas_data": "...", // シリアライズされた描画データ
            "last_saved_at": "2023-10-27T10:00:00Z"
        }
        ```
    - 失敗時: `HTTP 404 Not Found` など
- **補足**: フロントエンドはまずこのAPIで`canvas_data`を読み込み、ボードを初期化する。`canvas_data`がない場合は、`drawing_elements`を読み込むAPI（既存の`/api/v1/drawings/:drawing_id/elements`）を使用し、描画を再構築する。

#### 3. エクスポートAPI

- **目的**: 描画を特定のフォーマットでエクスポートする。
- **HTTPメソッド**: `POST`
- **パス**: `/api/v1/drawings/:drawing_id/export`
- **リクエスト**:
    - `drawing_id` (URLパラメータ): エクスポート対象の描画ボードのID。
    - `format` (string): "png", "jpeg", "svg" (例)
    - `image_data` (string): フロントエンドでCanvasから取得したData URL (PNG/JPEGの場合)
- **レスポンス**:
    - 成功時: `HTTP 200 OK` とともにファイルダウンロードをトリガーするレスポンスヘッダー（例: `Content-Disposition: attachment; filename="..."`）とファイルデータ。
    - 失敗時: `HTTP 400 Bad Request` または `HTTP 500 Internal Server Error`
- **注**: 初回実装ではフロントエンドでの直接エクスポートを優先するため、このAPIはオプションとする。

### Action Cable通信設計

#### 1. 描画要素のリアルタイムブロードキャスト
- **目的**: リアルタイムな描画イベントを他の共同編集者に即座に共有する。
- `DrawingChannel`を通じて、新しい`DrawingElement`が作成されるたびに、接続している全てのクライアントにその要素のJSONデータをブロードキャストする。
- このフローはリアルタイムコラボレーションのために維持される。

#### 2. 保存完了通知
- **目的**: 描画がサーバーで明示的に保存されたことをクライアントに通知する。
- **メッセージフォーマット**:
    ```json
    {
        "type": "drawing_saved",
        "drawing_id": 123,
        "last_saved_at": "2023-10-27T10:00:00Z"
    }
    ```
- **フロー**:
    1. クライアントが描画保存APIを呼び出す。
    2. サーバーサイドで`Drawing`モデルの`canvas_data`と`last_saved_at`が更新される。
    3. `DrawingChannel`を通じて、`drawing_saved`タイプのメッセージがブロードキャストされる。
    4. クライアントはこのメッセージを受信し、自身のUIの状態（例: 保存ボタンの非活性化、未保存マークの解除）を更新する。

### フロントエンド設計

#### 1. 描画キャンバスと保存機能の連携UI/UX

- **保存ボタン**:
    - キャンバス上部に「保存」ボタンを配置。
    - 未保存の変更がある場合のみ活性化し、変更がない場合は非活性化。
    - クリックで新しい保存APIを呼び出す。
- **エクスポートボタン**:
    - 「エクスポート」ボタンを配置。
    - クリックでエクスポートフォーマット選択モーダルを表示。
- **保存状態表示**:
    - 「保存済み」や「未保存の変更あり」といった状態を示すテキストをUIに表示。
    - 未保存の変更がある場合は、保存ボタンの横などに視覚的なインジケーター（例: アスタリスク、色変化）を表示する。

#### 2. Reactコンポーネントの役割分担と状態管理

- **`DrawingBoardPage.tsx` (または類似の親コンポーネント)**:
    - 描画ボード全体の状態を管理する。
    - `isDirty` (boolean): 未保存の変更があるかどうかを示す状態。描画操作が行われた際に`true`に設定し、保存APIが成功した際に`false`に設定する。
    - `lastSavedAt` (Date): 最終保存日時を保持し、`Drawing`モデルの`last_saved_at`と同期させる。
    - `DrawingCanvas`コンポーネントと`Toolbar`コンポーネント（保存/エクスポートボタンを含む）を子として持つ。
    - **初期読み込みロジック**:
        1.  `Drawing`モデルから`canvas_data`を読み込むAPIを呼び出す。
        2.  `canvas_data`が存在する場合、そのデータを使ってCanvasを初期化する。
        3.  `canvas_data`が存在しない場合（新規作成ボードなど）、`DrawingElement`を読み込むAPIを呼び出し、過去の要素を再構築する。
- **`DrawingCanvas.tsx`**:
    - 描画ロジックとCanvas要素を扱う。
    - 新しい描画要素が作成された際に、親コンポーネントに通知するコールバック（例: `onDrawingChange`）を提供する。
    - 「保存」ボタンがクリックされた際、現在のCanvasの状態をシリアライズし、親コンポーネント経由で保存APIに送信できる形式でデータを提供する。
- **`Toolbar.tsx`**:
    - 描画ツール（ペン、消しゴム、カラーピッカーなど）と保存/エクスポートボタンを配置する。
    - 保存ボタンは`isDirty`の状態に応じて活性/非活性を切り替える。
    - `onSave`、`onExport`などのコールバックを親コンポーネントから受け取る。
- **状態管理**: React Context APIや Zustand, Reduxなどの状態管理ライブラリを使用して、`DrawingElement`データや`isDirty`状態などを効率的に管理する。

#### 3. 未保存時のページ離脱警告

- **実装**:
    - `useEffect` フック内で `beforeunload` イベントリスナーを追加する。
    - イベントリスナー内で`isDirty`の状態を確認し、`true`であればイベントの`returnValue`を設定して警告をトリガーする。

#### 4. エクスポート機能のUIと処理

- **エクスポートモーダル**:
    - `ExportModal.tsx`コンポーネントを作成。
    - フォーマット選択用のラジオボタン（PNG, JPEG）とダウンロードボタンを持つ。
    - `設計書/カラーパレット.md`を参照し、デザインを統一する。
- **処理フロー**:
    1. ユーザーが「エクスポート」ボタンをクリック。
    2. `ExportModal`が表示される。
    3. ユーザーがフォーマットを選択し、「ダウンロード」をクリック。
    4. `DrawingBoardPage`コンポーネントはCanvas要素にアクセスし、`toDataURL()`メソッド（`image/png`または`image/jpeg`）で画像データを取得。
    5. 取得したデータURLを基に、`<a>`タグを動的に生成し、`href`にデータURL、`download`属性にファイル名を設定して、プログラム的にクリックをトリガーしダウンロードを開始する。

### エラーハンドリング
- **保存失敗時**:
    - APIからのエラーレスポンスをキャッチし、ユーザーにトーストメッセージなどで保存失敗を通知する。
    - 未保存の状態を維持し、再度保存を試せるようにする。
- **データ不整合時**:
    - 読み込み時にデータが破損している場合や、リアルタイム通信で不正なデータを受信した場合、エラーログを記録し、可能な限り正常な描画を試みる。
    - 致命的な場合は、ユーザーにエラーを通知し、再ロードを促す。

### セキュリティ
- **認証・認可**:
    - 保存API、読み込みAPI、エクスポートAPIは、ログイン済みのユーザーのみがアクセスできるようにする。
    - 各描画ボードは作成ユーザーに紐付けられ、そのボードへのアクセス権限を持つユーザー（共同編集者など）のみが描画の保存・閲覧・エクスポートを行えるように、サーバーサイドで認証・認可を厳格にチェックする。
    - `DrawingElement`の作成時も、ユーザーIDと`Drawing`IDの関連性を検証する。

### TODO
- **データベースマイグレーション**: `Drawing`モデルに`canvas_data`カラムを追加する。
- **バックエンド実装**:
    - 描画保存API（`/api/v1/drawings/:drawing_id/save`）の変更: `canvas_data`を受け取り、`Drawing`モデルに保存する。
    - 描画読み込みAPI（`/api/v1/drawings/:drawing_id`）の追加/変更: `canvas_data`を返す。
    - `DrawingElement`の定期的なクリーンアップ処理の実装。
- **フロントエンド実装**:
    - 「保存」ボタンクリック時のキャンバスデータシリアライズと保存API呼び出しロジックの実装。
    - 描画ボード初期読み込み時の`canvas_data`優先読み込みロジックの実装。
    - `DrawingElement`読み込みとのフォールバックロジックの実装。
- **Playwrightテストの拡充**: 新しい保存機能の動作検証を含む。
