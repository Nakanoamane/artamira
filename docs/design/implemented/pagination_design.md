# Artamira ページネーション機能設計書

## 1. 要件定義

### 1.1 背景

現状の描画ボード一覧ページ（Boards）では、以下の問題がある。
- ボードが作成順（古い順）に表示されており、新しく作成したボードが見つけづらい。
- 全てのボードが一度に読み込まれるため、ボード数が増えるとパフォーマンス劣化の懸念がある。
- 一度に表示されるボード数が多すぎるため、閲覧性が低い。

これらの問題を解決し、ユーザー体験を向上させるためにページネーション機能を導入する。

### 1.2 機能要件

- 描画ボード一覧ページにおいて、ボードを新しい順（`created_at`の降順）に表示すること。
- ページごとに表示されるボード数を制限すること。（例: 1ページあたり10件）
- ユーザーが次のページ、前のページ、あるいは特定のページに移動できるナビゲーションを提供すること。
- 現在のページ番号と総ページ数を表示すること。
- ページネーションによるパフォーマンスの改善。

## 2. 調査

### 2.1 現状の実装確認

- **バックエンド (`app/controllers/api/v1/drawings_controller.rb`):**
  - `index` アクションで `Drawing.all` を使用して全ての描画ボードを取得している。
  - 取得したデータをそのままJSONで返しているため、ページネーションの仕組みは現在のところない。
  - `show` アクションでは `last_saved_at` に基づいて `drawing_elements` を取得しているが、これは描画ボード一覧とは直接関係ない。

- **フロントエンド (`frontend/src/pages/DrawingList.tsx`):**
  - バックエンドの `/api/v1/drawings` エンドポイントから全ての描画ボードを取得している。
  - 取得した `drawings` ステートをそのまま `map` で表示している。
  - ページネーションUIは現在のところない。

### 2.2 技術選定

#### 2.2.1 バックエンド (Rails)

Railsでページネーションを実装する際には、いくつかのgemが広く利用されている。

- **Kaminari:**
  - **メリット:** シンプルなAPI、Railsのビューヘルパーとの統合が容易、カスタマイズ性が高い。
  - **デメリット:** 特になし。
- **Will Paginate:**
  - **メリット:** 長年の実績、Kaminariと同様に高機能。
  - **デメリット:** 特になし。

**選定理由:** `Kaminari` はRailsコミュニティで広く使われており、シンプルで柔軟なため、本プロジェクトに適していると判断。

#### 2.2.2 フロントエンド (React/TypeScript)

フロントエンドでページネーションを実装する際には、特別なライブラリは必須ではないが、状態管理やUIコンポーネントの設計が重要となる。

- **カスタム実装:**
  - **メリット:** 完全に制御可能、必要な機能のみを実装できるためバンドルサイズを抑えられる。
  - **デメリット:** 実装コストがかかる。
- **UIライブラリのページネーションコンポーネントの利用:**
  - **メリット:** 迅速な実装、デザインの一貫性、アクセシビリティの考慮。
  - **デメリット:** 不要な機能も含まれる可能性がある、カスタマイズが難しい場合がある。

**選定理由:** TailwindCSSでUIを構築しているため、既存のスタイルと合わせて柔軟にUIを構築できるカスタム実装が望ましい。ただし、状態管理は`useState`や`useEffect`を適切に活用する。

## 3. 設計

### 3.1 DB設計

既存の `drawings` テーブルに `created_at` カラムが存在するため、追加のスキーマ変更は不要。

### 3.2 バックエンド設計

#### 3.2.1 APIエンドポイントの変更

- **エンドポイント:** `/api/v1/drawings` (既存のエンドポイントを拡張)
- **HTTPメソッド:** `GET`
- **リクエストパラメータ:**
  - `page` (Integer, オプション): 取得するページ番号。デフォルトは1。
  - `per_page` (Integer, オプション): 1ページあたりの表示件数。デフォルトは任意の値（例: 10）。
- **レスポンス形式:**
  - 描画ボードの配列に加えて、ページネーション情報を追加する。
  - 例:
    ```json
    {
      "drawings": [
        { "id": 1, "title": "ボードA", "created_at": "..." },
        { "id": 2, "title": "ボードB", "created_at": "..." }
      ],
      "meta": {
        "total_pages": 5,
        "total_count": 50,
        "current_page": 1,
        "per_page": 10
      }
    }
    ```

#### 3.2.2 変更点

- `Gemfile` に `kaminari` gem を追加。
- `app/controllers/api/v1/drawings_controller.rb` の `index` アクションを修正。
  - `Drawing.all` を `Drawing.order(created_at: :desc).page(params[:page]).per(params[:per_page])` のように変更し、ページネーションを適用。
  - レスポンスに `meta` 情報を追加するために、Jbuilderテンプレート (`app/views/api/v1/drawings/index.json.jbuilder`) を更新。

### 3.3 フロントエンド設計

#### 3.3.1 UIの変更

- 描画ボード一覧の下部にページネーションコントロール（ページ番号、次へ/前へボタンなど）を表示。
- 現在のページと総ページ数を表示。

#### 3.3.2 API連携

- `fetchDrawings` 関数に `page` と `per_page` パラメータを渡すように変更。
- バックエンドからのレスポンスから `drawings` と `meta` 情報を取得し、それぞれのステートに保存。

#### 3.3.3 状態管理

- `useState` を使用して以下の状態を管理:
  - `drawings`: 現在のページに表示される描画ボードの配列。
  - `currentPage`: 現在のページ番号。
  - `totalPages`: 総ページ数。
  - `loading`: データ読み込み中を示すフラグ。
  - `error`: エラーメッセージ。

#### 3.3.4 変更点

- `frontend/src/pages/DrawingList.tsx` を修正。
  - `useState` で `currentPage` と `totalPages` を管理。
  - `useEffect` で `currentPage` が変更されるたびにAPIを呼び出すようにする。
  - ページネーションUIコンポーネントを実装し、イベントハンドラで `currentPage` を更新するロジックを記述。

## 4. 実行計画

### フェーズ1: バックエンドのページネーション実装
1. `Gemfile` に `kaminari` gem を追加し、`bundle install` を実行。
2. `app/controllers/api/v1/drawings_controller.rb` の `index` アクションに `kaminari` を適用し、新しい順で取得するように変更。
3. `app/views/api/v1/drawings/index.json.jbuilder` を作成または修正し、ページネーションメタデータを含むJSONレスポンスを生成するように変更。
4. バックエンドのテスト (`spec/requests/api/v1/drawings_controller_spec.rb`) を追加または修正し、ページネーションが正しく動作するか検証。

### フェーズ2: フロントエンドのページネーション実装
1. `frontend/src/pages/DrawingList.tsx` に `currentPage` と `totalPages` の状態を追加。
2. API呼び出し時に `page` と `per_page` パラメータを付与するように修正し、レスポンスからページネーションメタデータを取得するように変更。
3. ページネーションUIコンポーネント（「前へ」「次へ」「ページ番号」など）を `DrawingList.tsx` 内に実装。
4. ページネーションUIのインタラクションに基づいて `currentPage` を更新するロジックを実装。
5. フロントエンドのテスト (`frontend/src/tests/pages/DrawingList.test.tsx`) を追加または修正し、ページネーションUIと動作が正しく機能するか検証。

### フェーズ3: 結合テストと調整
1. バックエンドとフロントエンドを統合してテストし、ページネーションがエンドツーエンドで動作することを確認。
2. 1ページあたりの表示件数 (`per_page`) を調整し、最適なユーザー体験を提供するように調整。
3. UI/UXの最終的な調整。

## 5. プロンプト作成

実装計画に基づいて、各フェーズでAIに実装を依頼するための具体的なプロンプトを作成します。
