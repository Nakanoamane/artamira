# 保存機能設計書

## 概要
本設計書は、Artamiraにおける描画内容の保存、読み込み、ページ離脱時の警告、およびエクスポート機能の実装について詳述する。

## データベース設計

### 既存モデルへの影響と変更点

#### `Drawing` モデル
- **カラム追加**:
    - `last_saved_at`: `DATETIME`, `NULL: true` (描画の最終保存日時。未保存の変更を検知するために使用。)
- **変更理由**: フロントエンドで未保存の変更があるかを判断するために、最終保存日時を記録する必要があるため。

#### `DrawingElement` モデル
- **変更なし**: 既存の`drawing_id`, `user_id`, `element_type`, `data`カラムで描画要素の保存に十分対応可能。
- **`data`カラムのスキーマ (JSONB)**: 線の座標だけでなく、将来的な図形やテキスト要素にも対応できるよう、柔軟な構造を維持する。

### インデックスの考慮
- `drawing_id` と `user_id` は頻繁に検索されるため、既存のインデックスが適切に機能することを確認する。

## API設計

### 1. 描画保存API

- **目的**: 描画内容をデータベースに保存する。
- **HTTPメソッド**: `POST`
- **パス**: `/api/v1/drawings/:drawing_id/save`
- **リクエスト**:
    - `drawing_id` (URLパラメータ): 保存対象の描画ボードのID。
    - リクエストボディは、新しい`DrawingElement`のデータ、または既存の`DrawingElement`の変更・削除情報を含むが、リアルタイム描画と密接に連携するため、基本的に`DrawingElement`の作成はAction Cable経由で行い、このAPIは`Drawing`の`last_saved_at`の更新を主目的とする。
    - 例:
        ```json
        {
            "saved_elements_count": 5 // 保存された要素の数 (任意)
        }
        ```
- **レスポンス**:
    - 成功時: `HTTP 200 OK`
        ```json
        {
            "status": "success",
            "message": "Drawing saved successfully.",
            "last_saved_at": "2023-10-27T10:00:00Z"
        }
        ```
    - 失敗時: `HTTP 400 Bad Request` または `HTTP 500 Internal Server Error`

### 2. 描画読み込みAPI (既存)

- **目的**: 既存の描画内容を取得する。
- **HTTPメソッド**: `GET`
- **パス**: `/api/v1/drawings/:drawing_id/elements`
- **リクエスト**:
    - `drawing_id` (URLパラメータ): 読み込み対象の描画ボードのID。
- **レスポンス**:
    - 成功時: `HTTP 200 OK`
        ```json
        {
            "drawing_elements": [
                {
                    "id": 1,
                    "drawing_id": 1,
                    "user_id": 1,
                    "element_type": "line",
                    "data": { "points": [[10,20],[30,40]], "color": "#000000", "size": 2 }
                },
                // ...他のDrawingElement
            ],
            "last_saved_at": "2023-10-27T10:00:00Z" // 追加される情報
        }
        ```
    - 失敗時: `HTTP 404 Not Found` など

### 3. エクスポートAPI (バックエンド処理が必要な場合)

- **目的**: 描画を特定のフォーマットでエクスポートする。
- **HTTPメソッド**: `POST`
- **パス**: `/api/v1/drawings/:drawing_id/export`
- **リクエスト**:
    - `drawing_id` (URLパラメータ): エクスポート対象の描画ボードのID。
    - `format` (string): "png", "jpeg", "svg" (例)
    - `image_data` (string): フロントエンドでCanvasから取得したData URL (PNG/JPEGの場合)
- **レスポンス**:
    - 成功時: `HTTP 200 OK` とともにファイルダウンロードをトリガーするレスポンスヘッダー（例: `Content-Disposition: attachment; filename="..."`）とファイルデータ。
    - 失敗時: `HTTP 400 Bad Request` または `HTTP 500 Internal Server Error`
- **注**: 初回実装ではフロントエンドでの直接エクスポートを優先するため、このAPIはオプションとする。

## Action Cable通信設計

### 1. 描画要素のリアルタイムブロードキャスト (既存)
- `DrawingChannel`を通じて、新しい`DrawingElement`が作成されるたびに、接続している全てのクライアントにその要素のJSONデータをブロードキャストする。
- 既存のフローを維持し、保存機能とは独立して動作させる。

### 2. 保存完了通知 (新規)
- **目的**: 描画がサーバーで保存されたことをクライアントに通知する。
- **メッセージフォーマット**:
    ```json
    {
        "type": "drawing_saved",
        "drawing_id": 123,
        "last_saved_at": "2023-10-27T10:00:00Z"
    }
    ```
- **フロー**:
    1. クライアントが描画保存APIを呼び出す。
    2. サーバーサイドで`Drawing`モデルの`last_saved_at`が更新される。
    3. `DrawingChannel`を通じて、`drawing_saved`タイプのメッセージがブロードキャストされる。
    4. クライアントはこのメッセージを受信し、自身のUIの状態（例: 保存ボタンの非活性化、未保存マークの解除）を更新する。

## フロントエンド設計

### 1. 描画キャンバスと保存機能の連携UI/UX

- **保存ボタン**:
    - キャンバス上部に「保存」ボタンを配置。
    - 未保存の変更がある場合のみ活性化し、変更がない場合は非活性化。
    - クリックで保存APIを呼び出す。
- **エクスポートボタン**:
    - 「エクスポート」ボタンを配置。
    - クリックでエクスポートフォーマット選択モーダルを表示。
- **保存状態表示**:
    - 「保存済み」や「未保存の変更あり」といった状態を示すテキストをUIに表示。
    - 未保存の変更がある場合は、保存ボタンの横などに視覚的なインジケーター（例: アスタリスク、色変化）を表示する。

### 2. Reactコンポーネントの役割分担と状態管理

- **`DrawingBoardPage.tsx` (または類似の親コンポーネント)**:
    - 描画ボード全体の状態を管理する。
    - `DrawingElement`データの配列（既存の絵とリアルタイムで追加される要素）を保持。
    - `isDirty` (boolean): 未保存の変更があるかどうかを示す状態。描画操作が行われた際に`true`に設定し、保存APIが成功した際に`false`に設定する。
    - `lastSavedAt` (Date): 最終保存日時を保持し、`Drawing`モデルの`last_saved_at`と同期させる。
    - `DrawingCanvas`コンポーネントと`Toolbar`コンポーネント（保存/エクスポートボタンを含む）を子として持つ。
- **`DrawingCanvas.tsx`**:
    - 描画ロジックとCanvas要素を扱う。
    - 新しい描画要素が作成された際に、親コンポーネントに通知するコールバック（例: `onDrawingChange`）を提供する。
- **`Toolbar.tsx`**:
    - 描画ツール（ペン、消しゴム、カラーピッカーなど）と保存/エクスポートボタンを配置する。
    - 保存ボタンは`isDirty`の状態に応じて活性/非活性を切り替える。
    - `onSave`、`onExport`などのコールバックを親コンポーネントから受け取る。
- **状態管理**: React Context APIや Zustand, Reduxなどの状態管理ライブラリを使用して、`DrawingElement`データや`isDirty`状態などを効率的に管理する。

### 3. 未保存時のページ離脱警告

- **実装**:
    - `useEffect` フック内で `beforeunload` イベントリスナーを追加する。
    - イベントリスナー内で`isDirty`の状態を確認し、`true`であればイベントの`returnValue`を設定して警告をトリガーする。
    ```typescript
    useEffect(() => {
      const handleBeforeUnload = (event: BeforeUnloadEvent) => {
        if (isDirty) {
          event.preventDefault();
          event.returnValue = ''; // 古いブラウザ向け
        }
      };
      window.addEventListener('beforeunload', handleBeforeUnload);
      return () => {
        window.removeEventListener('beforeunload', handleBeforeUnload);
      };
    }, [isDirty]);
    ```

### 4. エクスポート機能のUIと処理

- **エクスポートモーダル**:
    - `ExportModal.tsx`コンポーネントを作成。
    - フォーマット選択用のラジオボタン（PNG, JPEG）とダウンロードボタンを持つ。
    - `設計書/カラーパレット.md`を参照し、デザインを統一する。
- **処理フロー**:
    1. ユーザーが「エクスポート」ボタンをクリック。
    2. `ExportModal`が表示される。
    3. ユーザーがフォーマットを選択し、「ダウンロード」をクリック。
    4. `DrawingBoardPage`コンポーネントはCanvas要素にアクセスし、`toDataURL()`メソッド（`image/png`または`image/jpeg`）で画像データを取得。
    5. 取得したデータURLを基に、`<a>`タグを動的に生成し、`href`にデータURL、`download`属性にファイル名を設定して、プログラム的にクリックをトリガーしダウンロードを開始する。

## エラーハンドリング

- **保存失敗時**:
    - APIからのエラーレスポンスをキャッチし、ユーザーにトーストメッセージなどで保存失敗を通知する。
    - 未保存の状態を維持し、再度保存を試せるようにする。
- **データ不整合時**:
    - 読み込み時にデータが破損している場合や、リアルタイム通信で不正なデータを受信した場合、エラーログを記録し、可能な限り正常な描画を試みる。
    - 致命的な場合は、ユーザーにエラーを通知し、再ロードを促す。

## セキュリティ

- **認証・認可**:
    - 保存API、読み込みAPI、エクスポートAPIは、ログイン済みのユーザーのみがアクセスできるようにする。
    - 各描画ボードは作成ユーザーに紐付けられ、そのボードへのアクセス権限を持つユーザー（共同編集者など）のみが描画の保存・閲覧・エクスポートを行えるように、サーバーサイドで認証・認可を厳格にチェックする。
    - `DrawingElement`の作成時も、ユーザーIDと`Drawing`IDの関連性を検証する。

---
