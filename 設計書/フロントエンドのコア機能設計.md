# フロントエンドのコア機能設計

この設計では、主に以下の3つの要素に焦点を当てます。

1.  **描画キャンバスコンポーネントの実装と描画ロジック**
2.  **Action Cableとのリアルタイムデータ送受信**
3.  **基本的なユーザーインターフェース（ツール選択、カラーピッカーなど）**

## 1. 描画キャンバスコンポーネントの実装と描画ロジック (`Canvas.tsx`)

*   **目的**: HTML5 `<canvas>` 要素を使用して描画を行い、ユーザーの入力（マウス/タッチイベント）を処理し、描画内容を管理します。
*   **コンポーネント**: `src/components/Canvas.tsx`
*   **主な機能**:
    *   **Canvasの初期化**: コンポーネントのマウント時にCanvas要素を取得し、2D描画コンテキスト (`getContext('2d')`) を初期化します。キャンバスサイズは固定値（例: 幅1200px、高さ800px）で設定し、背景は透過とします。
    *   **イベントハンドリング**: `onMouseDown` で描画開始点を記録し、`onMouseMove` でリアルタイムに描画、`onMouseUp`/`onMouseLeave` で描画を終了します。
    *   **描画状態の管理**: 現在の描画パス、描画中の要素、完了した描画要素のリストなどを管理します。
    *   **描画要素のレンダリング**: サーバーから受信した描画要素や、自身が描画した完了済みの要素をキャンバス上に描画します。各描画要素は、タイプ（線、図形など）、座標、色、太さなどのデータを持つオブジェクトとして定義します。
    *   **消しゴム機能**: `globalCompositeOperation = 'destination-out'` を使用し、描画部分を透明にします。

## 2. Action Cableとのリアルタイムデータ送受信

*   **目的**: バックエンドのAction CableチャネルとWebSocket接続を確立し、描画データのリアルタイム送受信を実現します。
*   **実装場所**: `src/pages/DrawingBoard.tsx` および `src/hooks/useDrawingChannel.ts`
*   **主な機能**:
    *   **WebSocket接続の確立とチャネル購読**: `@rails/actioncable` ライブラリを使用し、`DrawingChannel` を購読します。
    *   **データ送信**: ユーザーが描画を完了した際に、描画要素のデータをJSON形式でAction Cableチャネルに送信します。
    *   **データ受信と描画**: Action Cableチャネルからデータが受信された際、その描画要素を `Canvas` コンポーネントの描画要素リストに追加し、リアルタイムに表示を更新します。

## 3. 基本的なユーザーインターフェース (`Toolbar.tsx`, `ColorPicker.tsx`)

*   **目的**: ユーザーが描画ツール、色、太さを選択できるUIを提供し、`Canvas` コンポーネントの状態を制御します。
*   **コンポーネント**: `src/components/Toolbar.tsx` (または `src/components/ColorPicker.tsx` を含む)
*   **主な機能**:
    *   **ツール選択**: ペン、消しゴム、図形（直線、四角、円など）といった描画ツールを選択するためのボタンやアイコンを提供します。
    *   **ブラシサイズ選択**: 線の太さ（ブラシサイズ）を選択するためのスライダーを提供します。最大値は100とします。
    *   **UIのスタイリング**: TailwindCSSを使用して、これらのUI要素を美しくレスポンシブにスタイリングします。

## コンポーネント間のデータフロー

*   `DrawingBoard.tsx`:
    *   `Toolbar.tsx` と `Canvas.tsx` をレンダリングし、描画オプションの状態を一元管理します。
    *   `Toolbar` から更新を受け取り、`Canvas` にプロップスとして渡します。
    *   Action Cable接続と購読ロジックをホストし、受信した描画データを `Canvas` に渡します。
    *   `Canvas` からの描画完了イベントを受け取り、Action Cableを介してデータを送信するトリガーとなります。

## 実装計画

フロントエンドのコア機能実装について、以下のステップで実装を進めます。

### 完了済み

*   **環境設定と初期ファイル作成**: `src/components/Toolbar.tsx` を新規作成し、`BrushSizeSelector.tsx` と `ColorPicker.tsx` の機能を統合しました。
*   **`Toolbar.tsx` の実装**: ペンツール選択、カラーピッカー、ブラシサイズ選択のUIを実装し、親コンポーネント (`DrawingBoard.tsx`) に選択された値を渡すプロップスを定義しました。ブラシサイズの最大値を100に設定しました。
*   **`Canvas.tsx` の実装**:
    *   描画要素のリスト (`drawingElementsToRender`) を受け取り、キャンバス上にすべての描画要素をレンダリングするロジックを実装しました。
    *   描画クリア機能のプレースホルダーを追加しました。
    *   キャンバスのwrap要素に白い背景を設定しました。
    *   消しゴムツールが描画部分を透明にするロジックを実装しました。
    *   キャンバスの丸角を削除し、サイズを固定値（幅1200px、高さ800px）に設定しました。
*   **`DrawingBoard.tsx` の実装とコンポーネント連携**:
    *   `Toolbar.tsx` と `Canvas.tsx` をレンダリングし、描画オプションの状態を一元管理するように修正しました。
    *   `Canvas` からの描画完了イベントを受け取り、Action Cableを介してデータを送信するロジックを実装しました。
    *   `useDrawingChannel` の `onReceived` コールバックを `useCallback` でラップし、不要な再レンダリングを抑制しました。
*   **Action Cableとの連携**: `frontend/src/hooks/useDrawingChannel.ts` を作成し、WebSocket接続とチャネル購読、データ送受信ロジックをカプセル化しました。
*   **コンポーネント単体テスト**: Vitestへテストフレームワークを移行し、`Canvas.tsx`、`Toolbar.tsx`、`DrawingBoard.tsx` の単体テストを完了しました。
*   **アンドゥ/リドゥ機能**: `undoStack` と `redoStack` を用いた描画履歴管理ロジックを実装し、`Toolbar.tsx` にアンドゥ/リドゥボタンを追加し、履歴スタックの状態に応じて有効/無効を制御しました。
*   **カラーピッカー**: `react-colorful` を導入し、透過（alpha）選択、基本色選択ボタン、履歴色表示機能（3つまで）を実装しました。

### これから実装する内容

### テストの不足点

現在、以下のテストが不足しているか、網羅性の確認が必要です。

1.  **Vitest**:
    *   `DrawingList.tsx` の単体テスト
    *   `CreateDrawingForm.tsx` の単体テスト
    *   `ColorPicker.tsx` の単体テスト (現状、テストファイルが見当たらないため)

2.  **RSpec**:
    *   バックエンド側から見た Action Cable 連携の統合テスト（フロントエンドとのデータ送受信を想定し、チャネルの動作だけでなくシステム全体での連携を確認）

3.  **Playwright**:
    *   設計書に記載されている「リアルタイム共有」を含む、アプリケーション全体のユーザーフロー（描画ボードの作成、描画、リアルタイム共有、ツール切り替え、描画ボード一覧）が既存のE2Eテストで完全に網羅されているかの詳細な確認と、不足しているユーザーフローに対するテストの追加。

### この設計書に含まないこと

1.  **機能拡張と改善**
    *   **UIの改善**:
        *   `Toolbar.tsx` に新しい描画ツール（直線、四角、円）の選択ボタンとアイコンを追加。
        *   アクセシビリティ（キーボード操作、スクリーンリーダー対応）を考慮したUI設計。
        *   ツールアイコンの追加、選択状態の視覚的フィードバック、レスポンシブデザインの強化、キーボードショートカットの実装。
    *   **描画機能の拡張**:
        *   `Canvas.tsx` に直線、四角形、円ツールの描画ロジック（仮線描画と確定）を実装。
        *   各ツールの描画完了時に、Action Cableを通じて適切なデータ形式で描画データを送信するロジックを実装。
    *   **パフォーマンス最適化**: `onMouseMove` イベントにスロットリング/デバウンス処理を適用。描画要素の効率的な管理や差分更新を検討。
    *   **エラーハンドリングとローディング表示**: WebSocket接続状態、データ送受信エラー、ローディング表示をUIに反映。

2.  **テスト拡張**
    *   **コンポーネント単体テスト**: `DrawingList.tsx`、`CreateDrawingForm.tsx` のテストを実装。
    *   **Action Cable連携の統合テスト**: `useDrawingChannel` フックと `DrawingBoard.tsx` がAction Cableとのデータ送受信を正しく処理するかを確認。
    *   **E2Eテスト (Playwright)**: アプリケーション全体のユーザーフロー（描画ボードの作成、描画、リアルタイム共有、ツール切り替え、描画ボード一覧）をテスト。

### 実行計画

上記TODOの内容を、依存関係や緊急度に応じて順次実装していきます。
